/*   CASA Lib for ActionScript 3.0   Copyright (c) 2009, Aaron Clinger & Contributors of CASA Lib   All rights reserved.   Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions are met:   - Redistributions of source code must retain the above copyright notice,   this list of conditions and the following disclaimer.   - Redistributions in binary form must reproduce the above copyright notice,   this list of conditions and the following disclaimer in the documentation   and/or other materials provided with the distribution.   - Neither the name of the CASA Lib nor the names of its contributors   may be used to endorse or promote products derived from this software   without specific prior written permission.   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE. */package com.sleepydesign.display{	import com.sleepydesign.core.IDestroyable;		import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.Loader;	import flash.display.MovieClip;	import flash.display.SimpleButton;	import flash.display.Stage;	import flash.events.TimerEvent;	import flash.utils.Timer;
	/**	   Provides utility functions for DisplayObjects/DisplayObjectContainers.	   @author Aaron Clinger	   @version 05/25/09	 */	public class DisplayObjectUtil	{		private static var _deathNotes:Array; 		private static var _deathCallbacks:Array; 		private static var _deathTimer:Timer;				public static function kill(target:DisplayObject, onKill:Function):void		{			if(!target)				return;						if(target is DisplayObjectContainer)			{				gotoAndStopAll(target as DisplayObjectContainer);				removeChildren(target);			}						// kill from parent			if(target.parent)				target.parent.removeChild(target);						// no need to wait for 			if(!(target is MovieClip))				return;							// stop at last frame which is suppose to be null			if(target is MovieClip)				MovieClip(target).gotoAndStop(MovieClip(target).totalFrames);						// add to death list			if(!_deathNotes)				_deathNotes = [];							_deathNotes.push(target);						// tell me when it death			if(!_deathCallbacks)				_deathCallbacks = [];						_deathCallbacks.push(onKill);						// has someone to kill			if(_deathNotes.length > 0)			{				if(!_deathTimer)					_deathTimer = new Timer(2000);								_deathTimer.addEventListener(TimerEvent.TIMER, onDeathTimer);				_deathTimer.start();			} else{				_deathTimer.removeEventListener(TimerEvent.TIMER, onDeathTimer);				_deathNotes = null;				_deathCallbacks = null;								_deathTimer.stop();				_deathTimer = null;			}		}				private static function onDeathTimer(event:TimerEvent):void
		{			// seeking for no parent child to kill			var _deathNotes_length:int = _deathNotes.length;			for (var i:int = 0; i < _deathNotes_length; i++) 
			{
				if(!_deathNotes[i].parent)				{					// it's death					_deathCallbacks[i]();										// off list					removeItemAt(_deathNotes, i);					removeItemAt(_deathCallbacks, i);				}
			}						// no one left			if(_deathNotes.length == 0)			{				_deathTimer.removeEventListener(TimerEvent.TIMER, onDeathTimer);				_deathNotes = null;				_deathCallbacks = null;								_deathTimer.stop();				_deathTimer = null;			}
		}				public static function destroy(target:DisplayObjectContainer):void		{			gotoAndStopAll(target);			removeChildren(target);		}		public static function freeze(target:DisplayObjectContainer):void		{			target.mouseEnabled = false;			target.mouseChildren = false;			target.cacheAsBitmap = true;		}		/**		   Removes and optionally destroys children of a DisplayObjectContainer or the states of a SimpleButton.		   @param parent: The DisplayObjectContainer from which to remove children or a SimpleButton from which to remove its states.		   @param destroyChildren: If a child implements {@link IDestroyable} call its {@link IDestroyable#destroy destroy} method <code>true</code>, or don't destroy <code>false</code>; defaults to <code>false</code>.		   @param recursive: Call this method with the same arguments on all of the children's children (all the way down the display list) <code>true</code>, or leave the children's children <code>false</code>; defaults to <code>false</code>.		 */		public static function removeChildren(parent:DisplayObject, destroyChildren:Boolean = false, recursive:Boolean = false):void		{			if (parent is SimpleButton)			{				DisplayObjectUtil._removeButtonStates(parent as SimpleButton, destroyChildren, recursive);				return;			}			else if (parent is Loader || !(parent is DisplayObjectContainer))				return;			var container:DisplayObjectContainer = parent as DisplayObjectContainer;			while (container.numChildren)				DisplayObjectUtil._checkChild(container.removeChildAt(0), destroyChildren, recursive);		}		protected static function _removeButtonStates(parent:SimpleButton, destroyStates:Boolean, recursive:Boolean):void		{			if (parent.downState != null)			{				DisplayObjectUtil._checkChild(parent.downState, destroyStates, recursive);				parent.downState = null;			}			if (parent.hitTestState != null)			{				DisplayObjectUtil._checkChild(parent.hitTestState, destroyStates, recursive);				parent.hitTestState = null;			}			if (parent.overState != null)			{				DisplayObjectUtil._checkChild(parent.overState, destroyStates, recursive);				parent.overState = null;			}			if (parent.upState != null)			{				DisplayObjectUtil._checkChild(parent.upState, destroyStates, recursive);				parent.upState = null;			}		}		protected static function _checkChild(child:DisplayObject, destroy:Boolean, recursive:Boolean):void		{			var dest:IDestroyable;			if (destroy && child is IDestroyable)			{				dest = child as IDestroyable;				if (!dest.destroyed)					dest.destroy();			}			if (recursive)				DisplayObjectUtil.removeChildren(child, destroy, recursive);		}		public static function skinOf(container:DisplayObject, clazz:Class, checkMouseEnabled:Boolean = false):DisplayObject		{			if (!container)				return null;			if (checkMouseEnabled && !container["mouseEnabled"])				return null;			if (container is Stage || container.parent is Stage)				return null;			if (container is clazz)				return container;			return skinOf(container.parent, clazz, checkMouseEnabled);		}		public static function gotoAndStopAll(clip:DisplayObjectContainer, frameNum:int = 0):void		{			// static stuff			if (!clip)				return;			// stop itself			if (clip is MovieClip)				MovieClip(clip).gotoAndStop((frameNum == 0)?MovieClip(clip).totalFrames:frameNum);			// stop it own child(s)			var numChildren:int = clip.numChildren;			while (numChildren--)				gotoAndStopAll(clip.getChildAt(numChildren) as DisplayObjectContainer, frameNum);		}	}}function removeItemAt(arr:Array, index:int):*{	if (index == -1)		return index;		const item:* = arr[index];		arr.splice(index, 1);		return item;}function removeItem(arr:Array, item:*):*{	return removeItemAt(arr, arr.indexOf(item));}